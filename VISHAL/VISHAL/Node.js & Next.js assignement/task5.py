# -*- coding: utf-8 -*-
"""TARP_Group_6.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1yzuBdcRqnG0zwIdl2vKvIVosmQlnHAsf

### **Data Warehousing:**

---
"""

!gdown 1z5_AljvrhPB_uZ18gTISEDeUXdXiFFRE
!unzip tarp.zip

from pandas import *
from numpy.random import *
from numpy import *
import seaborn as sns
import matplotlib.pyplot as plt
import warnings
warnings.filterwarnings('ignore')

data_frame= read_csv('tarp/archive/zomato.csv',engine='python',index_col=0,encoding = 'unicode_escape')
country=read_excel('tarp/archive/Country-Code.xlsx',index_col=0)

country

data_frame.head(5)

data_frame.info()

data_frame.describe()

import json 
from pandas.io.json import json_normalize 

with open('tarp/archive/file2.json') as f:
  d = json.load(f)

nycphil = json_normalize(d)
nycphil.head()

import json 
from pandas.io.json import json_normalize 

with open('tarp/archive/file2.json') as f:
    d = json.load(f)

sam_json = json_normalize(d[0]["restaurants"])
sam_json.info()

sam_json["restaurant.id"]=sam_json["restaurant.id"].astype(int)

sam_json[sam_json["restaurant.id"]!=sam_json["restaurant.R.res_id"]]

rename={'restaurant.id': 'Restaurant ID', 'restaurant.name': 'Restaurant Name', 
 'restaurant.location.address': 'Address', 'restaurant.location.locality': 'Locality', 
 'restaurant.location.city': 'City', 'restaurant.location.latitude': 'Latitude', 
 'restaurant.location.longitude': 'Longitude', 'restaurant.location.country_id': 'Country Code',
 'restaurant.switch_to_order_menu': 'Switch to order menu', 'restaurant.cuisines': 'Cuisines',
 'restaurant.average_cost_for_two': 'Average Cost for two', 'restaurant.price_range': 'Price range',
 "restaurant.currency":"Currency", 'restaurant.user_rating.aggregate_rating':'Aggregate rating',
 'restaurant.user_rating.rating_text':'Rating text','restaurant.user_rating.rating_color':'Rating color',
 'restaurant.user_rating.votes':'Votes','restaurant.has_online_delivery':'Has Online delivery',
 'restaurant.is_delivering_now':'Is delivering now','restaurant.has_table_booking':'Has Table booking'
 }

all_col=set(sam_json.columns)
drop=list(all_col-(all_col&set(rename.keys())))

sam_json=sam_json.drop(drop,axis=1).rename(columns=rename).set_index('Restaurant ID')

sam_json.head(5)

combined_dataframe=concat([data_frame,sam_json])
combined_dataframe.info()

combined_dataframe.describe()

combined_dataframe.head()

data_combine_frame=[]
error_load=[]
def combine_data(file):
  global di
  loaded_file = json.load(open(file))
  for d in loaded_file:
    try:
      sam_json = json_normalize(d["restaurants"])
      sam_json["restaurant.id"]=sam_json["restaurant.id"].astype(int)
      sam_json=sam_json.drop(drop,axis=1).rename(columns=rename).set_index('Restaurant ID')
      data_combine_frame.append(sam_json)
    except KeyError:
      error_load.append(d)
      pass

import glob
json_files = glob.glob("archive/*.json")
for file in json_files:
  combine_data(file)

error_load

data_combine_frame=[data_frame]+data_combine_frame
data_warehouse=concat(data_combine_frame)

data_warehouse.info()

data_warehouse["Country Code"].unique()

data_warehouse["Currency"].unique()

data_warehouse["Currency"].replace(["Pounds(\x8c£)","NewZealand($)"],["Pounds(£)","NewZealand(NZ$)"],inplace=True)
data_warehouse["Currency"].unique()

cur=data_warehouse["Currency"].unique()
for i in cur:
  try:
    data_warehouse["Currency"].replace(i.split("(")[1].split(")")[0],i,inplace=True)
  except Exception:
    pass
data_warehouse["Currency"].unique()

data_warehouse["Price range"].unique()

data_warehouse["Has Table booking"].unique()

data_warehouse["Has Table booking"].replace([1,0],["Yes","No"],inplace=True)
data_warehouse["Has Table booking"].unique()

data_warehouse["Has Online delivery"].replace([1,0],["Yes","No"],inplace=True)
data_warehouse["Is delivering now"].replace([1,0],["Yes","No"],inplace=True)
data_warehouse["Switch to order menu"].replace([1,0],["Yes","No"],inplace=True)

data_warehouse=merge(data_warehouse, country, how="left", on="Country Code")
data_warehouse["Country"].unique()

#data_warehouse.drop(["restaurant.order_url","restaurant.order_deeplink","restaurant.zomato_events","restaurant.book_url","Locality Verbose","Country Code"],axis=1,inplace=True)

data_warehouse.head()

data_warehouse.info()

data_warehouse.describe()

data_warehouse.to_csv('DataWarehouse.csv',index=False)

"""### **Data Analysing**


---

"""

from pandas import *
from numpy.random import *
from numpy import *
import seaborn as sns
import matplotlib.pyplot as plt
import warnings
warnings.filterwarnings('ignore')
df= read_csv('tarp/DataWarehouse.csv',engine='python')

#Sorting the ratings of restaurants by country code
#We are rating the restraunts of a certain country code 
e = df[df['Rating text']=='Excellent']['Country'].value_counts()
vg = df[df['Rating text']=='Very Good']['Country'].value_counts()
gr = df[df['Rating text']=='Good']['Country'].value_counts()
ar = df[df['Rating text']=='Average']['Country'].value_counts()
pr = df[df['Rating text']=='Poor']['Country'].value_counts()
nr = df[df['Rating text']=='Not rated']['Country'].value_counts()


#display distinct contry codes
df["Country"].unique()

dfr = DataFrame([e,vg,gr,ar, pr,nr])
dfr.index = ['Excellent','Very Good','Good','Average','Poor','Not rated']
dfr.fillna(0) #while displaying replaces all null values with 0

dfr.describe()

#DATA EXPLORATION AND VISUALISATION 
dfr.plot(kind='bar',stacked=True, figsize=(8,8), title="Rating by Country")
plt.show()

#How many Restaurant accepting online orders
ax =df['Has Online delivery'].value_counts()
ax = ax.plot(kind='bar', color=['#1f77b4', '#ff7f0e'])
ax.set_xticklabels(['Does not accept online orders','Accepts online orders'], rotation=0)
plt.title('Number of Restaurants accepting online orders', weight='bold')
plt.xlabel('')
plt.ylabel('counts')
plt.show()


import matplotlib.pyplot as plt

online_orders = df['Has Online delivery'].value_counts(normalize=True)
labels = ['Does not accept online orders','Accepts online orders']
colors = ['#1f77b4', '#ff7f0e']
explode = (0.1, 0)
plt.pie(online_orders, explode=explode, labels=labels, colors=colors, autopct='%1.1f%%', shadow=True, startangle=90)
plt.axis('equal')
plt.title('Proportion of Restaurants accepting online orders', weight='bold')
plt.show()

#How many Restaurant have option to book a table
ax =df['Has Table booking'].value_counts().plot(kind='bar', color=plt.cm.Set2([0.2, 0.1]))
plt.title('Number of Restaurants has book table option', weight='bold')
plt.xlabel('book table facility')
plt.ylabel('counts')
plt.show()

#How many Restaurant have option to book a table
import matplotlib.pyplot as plt

table_booking = df['Has Table booking'].value_counts(normalize=True)
labels = ['No table booking option', 'Has table booking option']
colors = plt.cm.Set2([0.2, 0.1])
explode = (0.1, 0)
plt.pie(table_booking, explode=explode, labels=labels, colors=colors, autopct='%1.1f%%', shadow=True, startangle=90)
plt.axis('equal')
plt.title('Proportion of Restaurants with Table Booking Option', weight='bold')
plt.show()

#top 5 cities with most number of restraunts
plt.figure(figsize=(7,7))
ax =df['City'].value_counts()[:5].plot(kind='pie')
plt.title('Location', weight='bold')
plt.show()

#top 5 cities with most number of restaurants
import matplotlib.pyplot as plt

top_cities = df['City'].value_counts()[:5].sort_values(ascending=True)
labels = top_cities.index
counts = top_cities.values
colors = plt.cm.Set2([0.1, 0.2, 0.3, 0.4, 0.5])

fig, ax = plt.subplots(figsize=(8, 5))
ax.barh(labels, counts, color=colors)
ax.set_xlabel('Number of Restaurants')
ax.set_title('Top 5 Cities with the Most Restaurants', weight='bold')

# Add counts at the end of each bar
for i, count in enumerate(counts):
    ax.text(count + 10, i, str(count), ha='left', va='center')

plt.show()

#Average cost for 2 people to dine
values = df['Average Cost for two'].value_counts()[:10]
labels = df['Average Cost for two'].value_counts()[:10].index
plt.pie(values, labels=labels, autopct='%.2f')
plt.title('Average cost for two person(in %) ', weight='bold')
plt.show()

#Rating vs Online orders 
plt.figure(figsize = (12,6))
sns.countplot(x=df['Aggregate rating'], hue = df['Has Online delivery'])
plt.ylabel("Restaurants that Accept/Not Accepting online orders")
plt.title("rate vs online order",weight = 'bold')
plt.show()

#Displaying the ratings of the restaurants by price range (4 is high; 1 is low)
lowest_price = df[df['Price range']== 1]['Rating text'].value_counts()
lower_price = df[df['Price range']== 2]['Rating text'].value_counts()
higher_price = df[df['Price range']== 3]['Rating text'].value_counts()
highest_price = df[df['Price range']== 4]['Rating text'].value_counts()

df_price_by_rating = DataFrame([lowest_price,lower_price,higher_price,highest_price])
df_price_by_rating.index = ['Lowest Price (1)','Lower Price (2)','Higher Price (3)','Highest Price (4)']
df_price_by_rating.plot(kind='bar',stacked=True, figsize=(6,6), title="Price by Rating")
plt.show()


import pandas as pd
lowest_price = df[df['Price range']== 1]['Rating text'].value_counts()
lower_price = df[df['Price range']== 2]['Rating text'].value_counts()
higher_price = df[df['Price range']== 3]['Rating text'].value_counts()
highest_price = df[df['Price range']== 4]['Rating text'].value_counts()

df_price_by_rating = pd.DataFrame([lowest_price,lower_price,higher_price,highest_price])
df_price_by_rating.index = ['Lowest Price (1)','Lower Price (2)','Higher Price (3)','Highest Price (4)']

# Sorting the x-axis labels in descending order based on the average rating of each price range
df_price_by_rating['Average Rating'] = [df[df['Price range']== 1]['Aggregate rating'].mean(),
                                        df[df['Price range']== 2]['Aggregate rating'].mean(),
                                        df[df['Price range']== 3]['Aggregate rating'].mean(),
                                        df[df['Price range']== 4]['Aggregate rating'].mean()]
df_price_by_rating.sort_values(by='Average Rating', ascending=False, inplace=True)
df_price_by_rating.drop(columns=['Average Rating'], inplace=True)

# Displaying the stacked bar chart with labels and title
df_price_by_rating.plot(kind='bar',stacked=True, figsize=(6,6), title="Price by Rating")
plt.xlabel('Price Range')
plt.ylabel('Count')
plt.show()

df["Rating color"].unique()

sns.scatterplot(x='Aggregate rating',y='Votes',data=df)
plt.show()

import seaborn as sns
import matplotlib.pyplot as plt

sns.scatterplot(x='Aggregate rating', y='Votes', data=df)
plt.title('Aggregate Rating vs. Votes', weight='bold')
plt.xlabel('Aggregate rating')
plt.ylabel('Votes')
plt.show()

#Calculating the percentage of restaurants that were not rated:

#Total number of restaurants not rated in the training set
Number_of_restaurants_nr= dfr.loc['Not rated'].sum()
"""remove double reading"""

with open('tarp/DataWarehouse.csv',errors='ignore') as f:
    total_row_count = sum(1 for row in f)
    

number_of_restaurants_train= total_row_count * 0.7


Percentage_nr = (Number_of_restaurants_nr/number_of_restaurants_train)*100
print("Percentage of restaurants not rated =" ,round(Percentage_nr),"%")

"""### **Data Cleaning**

---


"""

from pandas import *
from numpy.random import *
from numpy import *
import seaborn as sns
import matplotlib.pyplot as plt
import warnings
warnings.filterwarnings('ignore')
df= read_csv('tarp/DataWarehouse.csv',engine='python')

# the lowest priced restaurants that are not rated
mean_lowest_price = df[df['Price range']== 1]['Aggregate rating'].replace(0.0, nan).mean()
print(f"Mean of aggregate rating with price range 1: {mean_lowest_price}")

# filling with their average
df[df['Price range']== 1]['Aggregate rating'].replace(0.0,nan, inplace=True)
df['Aggregate rating'].replace(nan, mean_lowest_price, inplace=True)

# the lowest priced restaurants that are not rated
new_mean_lowest_price = df['Aggregate rating'].replace(0.0, nan).mean()
print(f"New Mean of aggregate rating with price range 1: {new_mean_lowest_price}")

#Next the lower priced restaurants that are not rated
mean_lower_price = df[df['Price range']== 2]['Aggregate rating'].replace(0, nan).mean()
print(f"Mean of aggregate rating with price range 2: {mean_lowest_price}")

# filling with their average
df['Aggregate rating'].replace(0, mean_lower_price, inplace=True)

#Checking
print(df['Aggregate rating'].mean())

#Checking the new scatterplot, no restaurant has a rating of 0 now.
sns.scatterplot(x='Aggregate rating',y='Votes',data=df)
y=df["Rating text"]

#As an aggregate rating of 2.5-3.5 translates to a rating of "Average", the "Not Rated"
#text can be replaced with "Average" in the dependent variable.

y.replace('Not rated','Average', inplace=True)

#'Rating Text' and 'Rating Color' is given as a string. 
#encoded into numeric data so that the algorithm can perform calculations.

from sklearn.preprocessing import LabelEncoder
labelEncoder_X = LabelEncoder()
df["Rating text"]=labelEncoder_X.fit_transform(df["Rating text"])
#Shows that excellent = 1, very good = 4, good = 2, average = 0, and assuming poor = 3.
print(df["Rating text"].unique())
df["Rating color"]=labelEncoder_X.fit_transform(df["Rating color"])

for index, row in df.iterrows():
    try:
        l=row["Cuisines"].split(", ")
    except:
        continue
    
    for i in l:
        if i not in df.columns:
            df.loc[index,i]=1
            df[i].replace(nan, 0, inplace=True)
        df.loc[index,i]=1

df.drop(["Cuisines"],axis=1,inplace=True)

df.describe()

df['Latitude'].isnull().unique()

df['Longitude'].isnull().unique()

df["Has Online delivery"].replace(["Yes","No"],[1,0],inplace=True)
df["Is delivering now"].replace(["Yes","No"],[1,0],inplace=True)
df["Has Table booking"].replace(["Yes","No"],[1,0],inplace=True)
df['Switch to order menu'].replace(["Yes","No"],[1,0],inplace=True)

df = df.drop(['Restaurant Name',"Locality",'Country','City','Address','Currency',"Rating color",'Aggregate rating'], axis=1)

df.head()

df.to_csv('CleanedData.csv',index=False)

"""### **Model Training & Testing**

---


"""

from pandas import *
from numpy.random import *
from numpy import *
import seaborn as sns
import matplotlib.pyplot as plt
import warnings
warnings.filterwarnings('ignore')
df= read_csv('tarp/CleanedData.csv',engine='python')

df.head()

df.info()

y=df['Rating text'] 
X=df.drop(["Rating text"], axis=1) 
print(y)

from sklearn.model_selection import  train_test_split
x_train, x_test, y_train, y_test = train_test_split(X,y, test_size=0.3, random_state=0)
y_test

#used to save ml model for loading later
from pickle import dump

# Fitting K-NN to the Training set
from sklearn.neighbors import KNeighborsClassifier
classifier = KNeighborsClassifier(n_neighbors = 9, metric = 'minkowski', p = 2)

classifier.fit(x_train,y_train)
dump(classifier, open("knn.sav", 'wb'))
knn_score=classifier.score(x_test,y_test)
print(f"K-NN:\n Accuracy: {knn_score*100}%")

# Fitting Logistic Regression to the Training set
from sklearn.linear_model import LogisticRegression
classifier = LogisticRegression(penalty='l2',random_state = 0)

classifier.fit(x_train,y_train)
dump(classifier, open("logistic_regression.sav", 'wb'))
lr_score=classifier.score(x_test,y_test)
print(f"Logistic Regression:\n Accuracy: {lr_score*100}%")

# Fitting SVM to the Training set
from sklearn.svm import SVC
classifier = SVC(kernel = 'rbf', random_state = 0)

classifier.fit(x_train,y_train)
dump(classifier, open("svm.sav", 'wb'))
svm_score=classifier.score(x_test,y_test)
print(f"SVM:\n Accuracy: {svm_score*100}%")

# Fitting Naive Bayes to the Training set
from sklearn.naive_bayes import GaussianNB
classifier = GaussianNB()

classifier.fit(x_train,y_train)
dump(classifier, open("naive_bayes.sav", 'wb'))
nb_score=classifier.score(x_test,y_test)
print(f"Naive Bayes:\n Accuracy: {nb_score*100}%")

# Fitting Random Forest Classification to the Training set
from sklearn.ensemble import RandomForestClassifier
classifier = RandomForestClassifier(n_estimators = 100, criterion = 'entropy', random_state = 0)

classifier.fit(x_train,y_train)
dump(classifier, open("random_forest.sav", 'wb'))
rf_score=classifier.score(x_test,y_test)
print(f"Random Forest:\n Accuracy: {rf_score*100}%")

import matplotlib.pyplot as plt
import numpy as np

# Define the data
algos = ["K-NN","Logistic Regression","SVM","Naive Bayes","Random Forest"]
scores = [knn_score, lr_score, svm_score, nb_score, rf_score]
accuracies = np.array(scores) * 100

# Define the colors for the bars
colors = ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd']

# Create the figure and axes objects
fig, ax = plt.subplots(figsize=(10, 6))

# Create the bar plot
bars = ax.bar(algos, accuracies, color=colors, align='center', alpha=0.7, ecolor='black', capsize=10, width=0.6)

# Add the axis labels and title
ax.set_ylabel('Accuracy (%)', fontsize=14)
ax.set_xlabel('Algorithm', fontsize=14)
ax.set_title('Comparison of Machine Learning Algorithms', fontsize=16)

# Add the accuracy percentage to the top of each bar
for bar in bars:
    height = bar.get_height()
    ax.text(bar.get_x() + bar.get_width() / 2, height, f'{height:.2f}%', ha='center', va='bottom', fontsize=10)

# Create a legend for the labels
labels = ['K-NN', 'Logistic Regression', 'SVM', 'Naive Bayes', 'Random Forest']
handles = [plt.Rectangle((0,0),1,1, color=colors[i]) for i in range(len(labels))]
ax.legend(handles, labels, loc='upper left', bbox_to_anchor=(1, 1), fontsize=12)

# Add horizontal grid lines
ax.yaxis.grid(True)

# Adjust the plot layout
plt.tight_layout()

# Display the plot
plt.show()
plt.savefig('bar_plot_with_error_bars.png')